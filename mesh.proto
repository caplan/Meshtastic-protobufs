syntax = "proto3";
// per https://developers.google.com/protocol-buffers/docs/proto3

// We are not placing any of these defs inside a package, because if you do the
// resulting nanopb version is super verbose package mesh;

option java_package = "com.geeksville.mesh";
option java_outer_classname = "MeshProtos";

/**
MESH RADIO PROTOCOL

Old TODO notes on the mesh radio protocol, merge into real docs below...

for each named group we have a pre-shared key known by all group members and
wrapped around the device. you can only be in one group at a time (FIXME?!) To
join the group we read a qr code with the preshared key and ParamsCodeEnum. that
gets sent via bluetooth to the device.  ParamsCodeEnum maps to a set of various
radio params (regulatory region, center freq, SF, bandwidth, bitrate, power
etc...) so all members of the mesh can have their radios set the same way.

once in that group, we can talk between 254 node numbers.
to get our node number (and announce our presence in the channel) we pick a
random node number and broadcast as that node with WANT-NODENUM(my globally
unique name).  If anyone on the channel has seen someone _else_ using that name
within the last 24 hrs(?) they reply with DENY-NODENUM. Note: we might receive
multiple denies.  Note: this allows others to speak up for some other node that
might be saving battery right now. Any time we hear from another node (for any
message type), we add that node number to the unpickable list.  To dramatically
decrease the odds a node number we request is already used by someone. If no one
denies within TBD seconds, we assume that we have that node number.  As long as
we keep talking to folks at least once every 24 hrs, others should remember we
have it.

Once we have a node number we can broadcast POSITION-UPDATE(my globally unique
name, lat, lon, alt, amt battery remaining).  All receivers will use this to a)
update the mapping of who is at what node nums, b) the time of last rx, c)
position.  If we haven't heard from that node in a while we reply to that node
(only) with our current POSITION_UPDATE state - so that node (presumably just
rejoined the network) can build a map of all participants.

We will periodically broadcast POSITION-UPDATE as needed based on distance moved
or a periodic minimum heartbeat.

If user wants to send a text they can SEND_TEXT(dest user, short text message).
Dest user is a node number, or 0xff for broadcast.
*/

/*
Protobuf build instructions:

protoc -I=. --java_out /tmp mesh.proto

To generate Nanopb c code
/home/kevinh/packages/nanopb-0.4.0-linux-x86/generator-bin/protoc
--nanopb_out=/tmp -I=app/src/main/proto mesh.proto

Nanopb binaries available here: https://jpa.kapsi.fi/nanopb/download/ use nanopb
0.4.0

*/

// a gps position
message Position {

  /** The new preferred location encoding, divide by 1e-7 to get degrees in
   * floating point */
  sint32 latitude_i = 7;
  sint32 longitude_i = 8;

  /** In meters above MSL */
  int32 altitude = 3;

  /** 1-100 (0 means not provided) */
  int32 battery_level = 4;

  /// This is usually not sent over the mesh (to save space), but it is sent
  /// from the phone so that the local device can set its RTC If it is sent over
  /// the mesh (because there are devices on the mesh without GPS), it will only
  /// be sent by devices which has a hardware GPS clock.
  fixed32 time = 9; // seconds since 1970
}

// a data message to forward to an external app (or possibly also be consumed
// internally in the case of CLEAR_TEXT and CLEAR_READACK
message Data {
  enum Type {
    /// A message sent from a device outside of the mesh, in a form the mesh
    /// does not understand
    OPAQUE = 0; // NOTE: This must be 0, because it is documented in
    // IMeshService.aidl to be so

    /// a simple UTF-8 text message, which even the little micros in the mesh
    /// can understand and show on their screen eventually in some circumstances
    /// even signal might send messages in this form (see below)
    CLEAR_TEXT = 1;

    /// a message receive acknowledgement, sent in cleartext - allows radio to
    /// show user that a message has been read by the recipient, optional
    CLEAR_READACK = 2;

    /// Apps will eventually be able to register their own handlers for
    /// particular payload type codes so multiple apps can share the same radio
    /// (this will replace OPAQUE)
  }

  Type typ = 1;      // required
  bytes payload = 2; // required
}

/* Broadcast when a newly powered mesh node wants to find a node num it can use
// Sent from the phone over bluetooth to set the user id for the owner of this
node.
// Also sent from nodes to each other when a new node signs on (so all clients
can have this info)

The algorithm is as follows:
* when a node starts up, it broadcasts their user and the normal flow is for all
other nodes to reply with their User as well (so the new node can build its node
db)
* If a node ever receives a User (not just the first broadcast) message where
the sender node number equals our node number, that indicates a collision has
occurred and the following steps should happen:

If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
new User who just tried to sign in: it gets to keep its nodenum.  We send a
broadcast message of OUR User (we use a broadcast so that the other node can
receive our message, considering we have the same id - it also serves to let
observers correct their nodedb) - this case is rare so it should be okay.

If any node receives a User where the macaddr is GTE than their local macaddr,
they have been vetoed and should pick a new random nodenum (filtering against
whatever it knows about the nodedb) and rebroadcast their User.

A few nodenums are reserved and will never be requested:
0xff - broadcast
0 through 3 - for future use

*/
message User {
  string id = 1; // a globally unique ID string for this user.  In the case of
  // Signal that would mean +16504442323, for the default macaddr
  // derived id it would be !<6 hexidecimal bytes>
  string long_name = 2;  // A full name for this user, i.e. "Kevin Hester"
  string short_name = 3; // A VERY short name, ideally two characters.  Suitable
  // for a tiny OLED screen
  bytes macaddr = 4; // This is the addr of the radio.  Not populated by the
  // phone, but added by the esp32 when broadcasting
}

/// A message used in our Dynamic Source Routing protocol (RFC 4728 based)
message RouteDiscovery {

  /**
  The list of nodes this packet has visited so far
  */
  repeated int32 route = 2;
}

enum RouteError {
  NONE = 0;

  // Our node doesn't have a route to the requested destination anymore.
  NO_ROUTE = 1;

  // We received a nak while trying to forward on your behalf
  GOT_NAK = 2;

  TIMEOUT = 3;
}

// The payload portion fo a packet, this is the actual bytes that are sent
// inside a radio packet (because from/to are broken out by the comms library)
message SubPacket {

  // Only one of the following fields can be populated at a time
  oneof payload {

    Position position = 1;
    Data data = 3;
    User user = 4;

    /**
    A route request going from the requester
    */
    RouteDiscovery route_request = 6;

    /**
    A route reply
    */
    RouteDiscovery route_reply = 7;

    /**
    A failure in a routed message
    */
    RouteError route_error = 13;
  }

  /// Not normally used, but for testing a sender can request that recipient
  /// responds in kind (i.e. if it received a position, it should unicast back
  /// its position).
  // Note: that if you set this on a broadcast you will receive many replies.
  // FIXME - unify (i.e. remove) this with the new reliable messaging at the
  // MeshPacket level
  bool want_response = 5;

  oneof ack {
    /**
    This packet is a requested acknoledgement indicating that we have received
    the specified message ID.  This packet type can be used both for immediate
    (0 hops) messages or can be routed through multiple hops if dest is set.

    Note: As an optimization, recipients can _also_ populate a field in payload
    if they think the recipient would appreciate that extra state.
    */
    uint32 success_id = 10;

    /** This is a nak, we failed to deliver this message.
     */
    uint32 fail_id = 11;
  }

  /**
  The address of the destination node.

  This field is is filled in by the mesh radio device software, applicaiton
  layer software should never need it.

  RouteDiscovery messages _must_ populate this.  Other message types might need
  to if they are doing multihop routing.
  */
  uint32 dest = 9;

  /**
  The address of the original sender for this message.

  This field should _only_ be populated for reliable multihop packets (to keep
  packets small).
  */
  uint32 source = 12;

  /**
  Only used in route_error messages.  Indicates the original message ID that
  this message is reporting failure on.
  */
  uint32 original_id = 2;
}

// A full packet sent/received over the mesh
// Note: For simplicity reasons (and that we want to keep over the radio packets
// very small, we now assume that there is only _one_ SubPacket in each
// MeshPacket).
message MeshPacket {

  /**
  The sending node number.

  Note: Our crypto implementation uses this field as well.  See
  docs/software/crypto.md for details.
  */
  uint32 from = 1; // FIXME - really should be fixed32 instead, this encoding
                   // only hurts the ble link though.

  /**
  The (immediate) destination for this packet.  If we are using routing, the
  final destination will be in payload.dest
  */
  uint32 to = 2; // FIXME - really should be fixed32 instead, this encoding only
                 // hurts the ble link though.

  /**
  Internally to the mesh radios we will route SubPackets encrypted per
  docs/software/crypto.md.  However, when a particular node has the correct
  key to decode a particular packet, it will decode the payload into a SubPacket
  protobuf structure.

  Software outside of the device nodes will never encounter a packet where
  "decoded" is not populated (i.e. any encryption/decryption happens before
  reaching the applications)

  The numeric IDs for these fields were selected to keep backwards compatibility
  with old applications.
  */
  oneof payload {
    SubPacket decoded = 3;
    bytes encrypted = 8;
  }

  /**
  A unique ID for this packet.  Always 0 for no-ack packets or non broadcast
  packets (and therefore take zero bytes of space).  Otherwise a unique ID for
  this packet.  Useful for flooding algorithms.

  ID only needs to be unique on a _per sender_ basis.   And it only
  needs to be unique for a few minutes (long enough to last for the length of
  any ACK or the completion of a mesh broadcast flood).

  Note: Our crypto implementation uses this id as well.  See
  docs/software/crypto.md for details.
  */
  uint32 id = 6; // FIXME - really should be fixed32 instead, this encoding only
                 // hurts the ble link though.

  /// The time this message was received by the esp32 (secs since 1970).  Note:
  /// this field is _never_ sent on the radio link itself (to save space) Times
  /// are typically not sent over the mesh, but they will be added to any Packet
  /// (chain of SubPacket) sent to the phone (so the phone can know exact time
  /// of reception)
  fixed32 rx_time = 9;

  /// *Never* sent over the radio links.  Set during reception to indicate the
  /// SNR
  /// of this packet.  Used to collect statistics on current link waulity.
  float rx_snr = 7;

  /**
  If unset treated as zero (no fowarding, send to adjacent nodes only)
  if 1, allow hopping through one node, etc...

  For our usecase real world topologies probably have a max of about 3.

  This field is normally placed into a few of bits in the header.
  */
  uint32 hop_limit = 10;

  /**
  This packet is being sent as a reliable message, we would prefer it to arrive
  at the destination.  We would like to receive a ack packet in response.

  Broadcasts messages treat this flag specially: Since acks for broadcasts would
  rapidly flood the channel, the normal ack behavior is suppressed.  Instead,
  the original sender listens to see if at least one node is rebroadcasting this
  packet (because naive flooding algoritm).  If it hears that the odds (given
  typical LoRa topologies) the odds are very high that every node should
  eventually receive the message.  So FloodingRouter.cpp generates an implicit
  ack which is delivered to the original sender. If after some time we don't
  hear anyone rebroadcast our packet, we will timeout and retransmit, using the
  regular resend logic.

  Note: This flag is normally sent in a flag bit in the header when sent over
  the wire
  */
  bool want_ack = 11;
}

/// Shared constants between device and phone
enum Constants {
  Unused = 0; // First enum must be zero, and we are just using this enum to
  // pass int constants between two very different environments
}

/** Full settings (center freq, spread factor, pre-shared secret key etc...)
needed to configure a radio for speaking on a particlar channel This
information can be encoded as a QRcode/url so that other users can configure
their radio to join the same channel.

A note aboute how channel names are shown to users:

#channelname-Xy

# is a prefix used to indicate this is a channel name (idea from @professr).

Where X is a letter from A-Z (base 26) representing a hash of the PSK for this
channel - so that if the user changes anything about the channel (which does
force a new PSK) this letter will also change. Thus preventing user confusion if
two friends try to type in a channel name of "BobsChan" and then can't talk
because their PSKs will be different.  The PSK is hashed into this letter by
"0x41 + [xor all bytes of the psk ] modulo 26"

This also allows the option of someday if people have the PSK off (zero), the
users COULD type in a channel name and be able to talk.

Y is a lower case letter from a-z that represents the channel 'speed' settings
(for some future definition of speed)
*/
message ChannelSettings {

  /**
  If zero then, use default max legal continuous power (ie. something that won't
  burn out the radio hardware)

  In most cases you should use zero here.
  */
  int32 tx_power = 1;

  enum ModemConfig {
    // Note: these mappings must match ModemConfigChoice in the device code.
    Bw125Cr45Sf128 = 0; ///< Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC
    ///< on. Default medium range
    Bw500Cr45Sf128 = 1; ///< Bw = 500 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC
    ///< on. Fast+short range
    Bw31_25Cr48Sf512 = 2; ///< Bw = 31.25 kHz, Cr = 4/8, Sf = 512chips/symbol,
    ///< CRC on. Slow+long range
    Bw125Cr48Sf4096 = 3; ///< Bw = 125 kHz, Cr = 4/8, Sf = 4096chips/symbol, CRC
    ///< on. Slow+long range
  }

  /// Note: This is the 'old' mechanism for specifying channel parameters.
  /// Either modem_config or bandwidth/spreading/coding will be specified - NOT
  /// BOTH. As a heuristic: If bandwidth is specified, do not use modem_config.
  /// Because protobufs take ZERO space when the value is zero this works out
  /// nicely.
  ///
  /// This value replaces bandwidth/spread_factor/coding_rate.  If you'd like to
  /// experiment with other options add them to MeshRadio.cpp in the device
  /// code.
  ModemConfig modem_config = 3;

  /// See note above with modem_config
  /**
  Bandwidth in MHz
  Certain bandwidth numbers are 'special' and will be converted to the
  appropriate floating point value: 31 -> 31.25MHz
  */
  uint32 bandwidth = 6;

  /**
  A number from 7 to 12.  Indicates number of chirps per symbol as
  1<<spread_factor.
  */
  uint32 spread_factor = 7;

  /**
  The denominator of the coding rate.  ie for 4/8, the value is 8. 5/8 the value
  is 5.
  */
  uint32 coding_rate = 8;

  /**
  A channel number between 1 and 13 (or whatever the max is in the current
  region). If ZERO then the rule is "use the old channel name hash based
  algoritm to derive the channel number")
  */
  uint32 channel_num = 9;

  /// A simple preshared key for now for crypto.  Must be either 0 bytes (no
  /// crypto), 16 bytes (AES128), or 32 bytes (AES256)
  bytes psk = 4;

  /// A SHORT name that will be packed into the URL.  Less than 12 bytes.
  /// Something for end users to call the channel
  string name = 5;
}

// The entire set of user settable/readable settings for our radio device.
// Includes both the current channel settings and any preferences the user has
// set for behavior of their node
message RadioConfig {

  message UserPreferences {
    // We should send our position this often (but only if it has changed
    // significantly)
    uint32 position_broadcast_secs = 1;

    // Send our owner info at least this often (also we always send once at boot
    // - to rejoin the mesh)
    uint32 send_owner_interval = 2;

    /// If we miss this many owner messages from a node, we declare the node
    /// offline (defaults to 3 - to allow for some lost packets)
    uint32 num_missed_to_fail = 3;

    /// see sw-design.md
    uint32 wait_bluetooth_secs = 4;
    uint32 screen_on_secs = 5;
    uint32 phone_timeout_secs = 6;
    uint32 phone_sds_timeout_sec = 7;
    uint32 mesh_sds_timeout_secs = 8;
    uint32 sds_secs = 9;
    uint32 ls_secs = 10;
    uint32 min_wake_secs = 11;

    /** If set, this node will try to join the specified wifi network and
     * acquire an address via DHCP */
    string wifi_ssid = 12;
    /** If set, will be use to authenticate to the named wifi */
    string wifi_password = 13;
    /** If set, the node will operate as an AP (and DHCP server), otherwise it
     * will be a station */
    bool wifi_ap_mode = 14;

    // If true, radio should not try to be smart about what packets to queue to
    // the phone
    // bool keep_all_packets = 100;

    // If true, we will try to capture all the packets sent on the mesh, not
    // just the ones destined to our node.
    // bool promiscuous_mode = 101;

    /**
    For testing it is useful sometimes to force a node to never listen to
    particular other nodes (simulating radio out of range). All nodenums listed
    in ignore_incoming will have packets they send droped on receive (by
    router.cpp)
    */
    repeated uint32 ignore_incoming = 102;
  }

  UserPreferences preferences = 1;
  ChannelSettings channel_settings = 2;
}

/**

The bluetooth to device link:

Old BTLE protocol docs from TODO, merge in above and make real docs...

use protocol buffers, and NanoPB

messages from device to phone:
POSITION_UPDATE (..., time)
TEXT_RECEIVED(from, text, time)
OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)

messages from phone to device:
SET_MYID(id, human readable long, human readable short) (send down the unique ID
string used for this node, a human readable string shown for that id, and a very
short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
(for signal messages or other applications) SEND_TEXT(dest, text) Get all
nodes() (returns list of nodes, with full info, last time seen, loc, battery
level etc) SET_CONFIG (switches device to a new set of radio params and
preshared key, drops all existing nodes, force our node to rejoin this new
group)

*/

// Full information about a node on the mesh
message NodeInfo {
  uint32 num = 1; // the node number
  User user = 2;

  /// This position data will also contain a time last seen
  Position position = 3;

  /// Returns the Signal-to-noise ratio (SNR) of the last received message, as
  /// measured by the receiver. return SNR of the last received message in dB
  float snr = 7;

  /// Returns the last measured frequency error.
  /// The LoRa receiver estimates the frequency offset between the receiver
  /// centre frequency and that of the received LoRa signal. This function
  /// returns the estimates offset (in Hz) of the last received message.
  /// Caution: this measurement is not absolute, but is measured relative to the
  /// local receiver's oscillator. Apparent errors may be due to the
  /// transmitter, the receiver or both. \return The estimated centre frequency
  /// offset in Hz of the last received message.
  // int32 frequency_error = 6;

  /* enum RouteState {
    Invalid = 0;
    Discovering = 1;
    Valid = 2;
  }

  Not needed?
  RouteState route = 4; */

  /// Our current preferred node node for routing - might be the same as num if
  /// we are adjacent Or zero if we don't yet know a route to this node.
  uint32 next_hop = 5;
}

/**
Unique local debugging info for this node

Note: we don't include position or the user info, because that will come in the

Sent to the phone in response to WantNodes.
*/
message MyNodeInfo {
  /// Tells the phone what our node number is, default starting value is lowbyte
  /// of macaddr, but it will be fixed if that is already in use
  uint32 my_node_num = 1;

  /// if false it would be great if the phone can help provide gps coordinates
  bool has_gps = 2;

  /// # of legal channels (set at build time in the device flash image)
  int32 num_channels = 3;

  /// The region code for my radio (US, CN, etc...)
  string region = 4;

  /// TBEAM, HELTEC, etc...
  string hw_model = 5;

  /// 0.0.5 etc...
  string firmware_version = 6;

  /// An error message we'd like to report back to the mothership through
  /// analytics.  It indicates a serious bug occurred on the device, the device
  /// coped with it, but we still want to tell the devs about the bug. This
  /// field will be cleared after the phone reads MyNodeInfo (i.e. it will only
  /// be reported once) a numeric error code to go with error message, zero
  /// means no error
  uint32 error_code = 7;

  /// A numeric error address (nonzero if available)
  uint32 error_address = 8;

  /// The total number of errors this node has ever encountered (well - since
  /// the last time we discarded preferences)
  uint32 error_count = 9;

  /** How many bits are used for the packetid.  If zero it is assumed we use
  eight bit packetids Old device loads (older that 0.6.5 do not populate this
  field, but all newer loads do). */
  uint32 packet_id_bits = 10;

  /** The current ID this node is using for sending new packets (exposed so that
  the phone can self assign packet IDs if it wishes by picking packet IDs from
  the opposite side of the pacekt ID space).

  Old device loads (older that 0.6.5 do not populate this field, but all newer
  loads do).

  FIXME: that we need to expose this is a bit of a mistake.  Really the phones
  should be modeled/treated as 1st class nodes like any other, and the radio
  connected to the phone just routes like any other. This would allow all sorts
  of clean/clever routing topologies in the future.
  **/
  uint32 current_packet_id = 11;

  /** How many bits are used for the nodenum.  If zero it is assumed we use
  eight bit nodenums New device loads will user 32 bit nodenum.
  Old device loads (older that 0.6.5 do not populate this field, but all newer
  loads do). */
  uint32 node_num_bits = 12;

  /** How long before we consider a message abandoned and we can clear our
  caches of any messages in flight Normally quite large to handle the worst case
  message delivery time, 5 minutes.  Formerly called FLOOD_EXPIRE_TIME in the
  device code
  */
  uint32 message_timeout_msec = 13;

  /** The minimum app version that can talk to this device.  Android apps should
  compare this to their build number and if too low tell the user they must
  update their app
  */
  uint32 min_app_version = 14;

  /// FIXME - add more useful debugging state (queue depths etc)
}

// This message is never sent over the wire, but it is used for serializing DB
// state to flash in the device code
// FIXME, since we write this each time we enter deep sleep (and have infinite
// flash) it would be better to use some sort of append only data structure for
// the receive queue and use the preferences store for the other stuff
message DeviceState {
  RadioConfig radio = 1;

  /// Read only settings/info about this node
  MyNodeInfo my_node = 2;

  /// My owner info
  User owner = 3;

  repeated NodeInfo node_db = 4;

  /// Received packets saved for delivery to the phone
  repeated MeshPacket receive_queue = 5;

  /// A version integer used to invalidate old save files when we make
  /// incompatible changes This integer is set at build time and is private to
  /// NodeDB.cpp in the device code.
  uint32 version = 8;

  /// We keep the last received text message (only) stored in the device flash,
  /// so we can show it on the screen.  Might be null
  MeshPacket rx_text_message = 7;

  /// Used only during development.  Indicates developer is testing and changes
  /// should never be saved to flash.
  bool no_save = 9;
}

/// Debug output from the device
message DebugString {
  string message = 1;

  // eventually we might add source and level
}

// packets from the radio to the phone will appear on the fromRadio
// characteristic.  It will support READ and NOTIFY.  When a new packet arrives
// the device will notify?  possibly identify instead? it will sit in that
// descriptor until consumed by the phone, at which point the next item in the
// FIFO will be populated.  FIXME
message FromRadio {
  // The packet num, used to allow the phone to request missing read packets
  // from the FIFO, see our bluetooth docs
  uint32 num = 1;

  oneof variant {
    MeshPacket packet = 2;

    /// Tells the phone what our node number is, can be -1 if we've not yet
    /// joined a mesh.
    // REV2: In the rev 1 API this is in the BLE mynodeinfo characteristic
    MyNodeInfo my_info = 3;

    /// One packet is sent for each node in the on radio DB
    // REV2: In the rev1 API this is available in the nodeinfo characteristic
    // starts over with the first node in our DB
    NodeInfo node_info = 4;

    /// REV2: In rev1 this was the Owner BLE characteristic
    // Note: there is no separate payload for reading the owner, it comes
    // implicitly as part of the NodeInfo for whichever node corresponds to our
    // device. User owner = 5;

    /// REV2: In rev1 this was the radio BLE characteristic
    RadioConfig radio = 6;

    /// REV2: set to send debug console output over our protobuf stream
    DebugString debug_string = 7;

    /// REV2: sent as true once the device has finished sending all of the
    /// responses to want_config
    /// recipient should check if this ID matches our original request nonce, if
    /// not, it means your config responses haven't started yet
    uint32 config_complete_id = 8;

    /// Sent to tell clients the radio has just rebooted.  Set to true if
    /// present.  Not used on all transports, currently just used for the serial
    /// console.
    bool rebooted = 9;
  }
}

// packets/commands to the radio will be written (reliably) to the toRadio
// characteristic.  Once the write completes the phone can assume it is handled.
message ToRadio {

  oneof variant {
    MeshPacket packet = 1; // send this packet on the mesh

    /// REV2: phone wants radio to send full node db to the phone, This is
    /// typically the first packet sent to the radio when the phone gets a
    /// bluetooth connection. The radio will respond by sending back a
    /// MyNodeInfo, a owner, a radio config and a series of
    /// FromRadio.node_infos, and config_complete
    /// the integer you write into this field will be reported back in the
    /// config_complete_id response this allows clients to never be confused by
    /// a stale old partially sent config.
    uint32 want_config_id = 100;

    /// REV2: In rev1 this was the radio config characteristic
    RadioConfig set_radio = 101; // set the radio provisioning for this node

    /// REV2: In rev1 this was the owner characteristic
    User set_owner = 102; // Set the owner for this node
  }
}

/**
Placeholder for data we will eventually set during initial programming.  This
will allow us to stop having a load for each region.
*/
message ManufacturingData {
  /// center frequency for the radio hardware that was stuffed
  uint32 fradioFreq = 1;

  /// TBEAM, HELTEC, etc...
  string hw_model = 2;

  // Hardware version number
  string hw_version = 3;

  /**
  This code is written during manfacturing time and allows users to confirm that
  the initial manufacturing tests succeeded.

  0 means no test performed.
  1 means all tests passed
  negative numbers indicate particular error codes
  */
  sint32 selftest_result = 4;
}